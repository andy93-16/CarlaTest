#!/usr/bin/env python

# Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

import glob
import os
import sys

try:

    sys.path.append(glob.glob('../carla/dist/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])

except IndexError:
    pass

import carla

from carla import ColorConverter as cc

import random
import time
import pygame
import weakref

# script to make motion planning with image processing
import image_processing
import motion_planning
import math

try:
    import numpy as np
except ImportError:
    raise RuntimeError('cannot import numpy, make sure numpy package is installed')



def main():

    # In this tutorial script, we are going to add a vehicle to the simulation
    # and let it drive in autopilot. We will also create a camera attached to
    # that vehicle, and save all the images generated by the camera to disk.

    try:
        # First of all, we need to create the client that will send the requests
        # to the simulator. Here we'll assume the simulator is accepting
        # requests in the localhost at port 2000.
        client = carla.Client('localhost', 2000)
        client.set_timeout(5.0)

        # Once we have a client we can retrieve the world that is currently
        # running
        
        if client.get_world().get_map() != 'Town02':
           world = client.load_world('Town02')

        world=client.reload_world()

        # Set world weather parameters
        weather = carla.WeatherParameters(cloudyness=0.0, precipitation=0.0,
                wind_intensity=0.0, sun_azimuth_angle=5.71, sun_altitude_angle=42.25)
                
        world.set_weather(weather)

        #for point in world.get_map().get_spawn_points():
        # print(point)

        # The world contains the list blueprints that we can use for adding new
        # actors into the simulation.
        blueprint_library = world.get_blueprint_library()

        # Now let's find blueprint of type 'vehicle' named 'audi.etron'
        bp = blueprint_library.find('vehicle.audi.etron')

        # A blueprint contains the list of attributes that define a vehicle's
        # instance, we can read them and modify some of them. For instance,
        # let's randomize its color.
        if bp.has_attribute('color'):
            color = random.choice(bp.get_attribute('color').recommended_values)
            bp.set_attribute('color', color)

        # So let's tell the world to spawn the vehicle at a certain transform to make
        # desired test
        vehicle = world.spawn_actor(bp,carla.Transform(
                location=carla.Location(x=136.110016, y=306.420044, z=1.370000))) #Town02


        #vehicle = world.spawn_actor(bp,carla.Transform(
        #        location=carla.Location(x=-229.988586, y=6.678692, z=15.200020),
        #        rotation=carla.Rotation(pitch=0.000000, yaw=-90.337494, roll=0.000000))) #Town05

        
        #vehicle.set_autopilot(True)

        # It is important to note that the actors we create won't be destroyed
        # unless we call their "destroy" function. If we fail to call "destroy"
        # they will stay in the simulation even after we quit the Python script.
        # For that reason, we are storing all the actors we create so we can
        # destroy them afterwards.
        print('created %s' % vehicle.type_id)

        #In this section, we are setting needed pygame instance to display
        #test information.
        #Pygame window is composed by third person view of the vehicle, another
        #small window with result of image_processing and other information about
        #vehicle state
        pygame.init()
        pygame.font.init()
        display = pygame.display.set_mode(
            (640,480),
            pygame.HWSURFACE | pygame.DOUBLEBUF)
        hud=HUD(640,480)
        camera_manager=CameraManager(vehicle,hud)
        #parameter of set_sensot config_index choose, transform config index, fov config index
        camera_manager.set_sensor(0,0,0) #set and enable sensor of the rear RGB camera
        camera_manager.set_sensor(5,1,1) #set and enablesensor of the forward sematic_segmation camera
        hud.sensors_mini_surface.append(camera_manager.sensors[1]) #set in hud the small view of the forward camer

        #pricipal loop with time delay
        while True:
            camera_manager.render(display, 0) #render RGB camera
            hud.tick(vehicle) #update vehicle information
            hud.render(display) #render image_processing
            curr_steering_angle = camera_manager.steering_angle
            #steering angle is store in camera_manager class, this is because image_process run inside the class
            if curr_steering_angle is not None:
                #vehicle apply_control with fix speed
                vehicle.apply_control(carla.VehicleControl(steer=curr_steering_angle, throttle=0.25))
            pygame.display.flip() #render all in window
            world.tick() #tick the simulator to appy vehicle control after setting all
            #time.sleep(0.05)  #delay

    finally:

        vehicle.destroy()
        print('done.')

# ==============================================================================
# -- SENSOR GAME -----------------------------------------------------------------------
# ==============================================================================

        
class SensorGame(object):
    def __init__(self,sensor):        
        self.surface = None
        self.sensor=sensor

# ==============================================================================
# -- CAMERA MANAGER -----------------------------------------------------------------------
# ==============================================================================

        
class CameraManager(object):
    def __init__(self, parent_actor, hud):
        self.steering_angle= 0.0
        self.surface = None
        self._parent = parent_actor
        self.hud = hud
        self.sensors = []
        self._camera_transforms = [carla.Transform(carla.Location(x=-5,z=3), carla.Rotation(pitch=-15.0)),
             carla.Transform(carla.Location(x=2.5, z=1.2), carla.Rotation(pitch=-15.0))]
        self._camera_fov = [90,110]
        self.sensors_config = [
            ['sensor.camera.rgb', cc.Raw, 'Camera RGB'],
            ['sensor.camera.depth', cc.Raw, 'Camera Depth (Raw)'],
            ['sensor.camera.depth', cc.Depth, 'Camera Depth (Gray Scale)'],
            ['sensor.camera.depth', cc.LogarithmicDepth, 'Camera Depth (Logarithmic Gray Scale)'],
            ['sensor.camera.semantic_segmentation', cc.Raw, 'Camera Semantic Segmentation (Raw)'],
            ['sensor.camera.semantic_segmentation', cc.CityScapesPalette,
             'Camera Semantic Segmentation (CityScapes Palette)'],
            ['sensor.lidar.ray_cast', None, 'Lidar (Ray-Cast)']]
        world = self._parent.get_world()
        bp_library = world.get_blueprint_library()
        for item in self.sensors_config:
            bp = bp_library.find(item[0])
            if item[0].startswith('sensor.camera'):
                bp.set_attribute('image_size_x', str(hud.dim[0]))
                bp.set_attribute('image_size_y', str(hud.dim[1]))
            elif item[0].startswith('sensor.lidar'):
                bp.set_attribute('range', '5000')   
            item.append(bp)

    def set_sensor(self, config_index, transform_index,fov_index):
        self.sensors_config[config_index][-1].set_attribute('fov',str(self._camera_fov[fov_index]))
        sensor_game=SensorGame(self._parent.get_world().spawn_actor(self.sensors_config[config_index][-1],
                      self._camera_transforms[transform_index], attach_to=self._parent))
        self.sensors.append(sensor_game)                                  
        # We need to pass the lambda a weak reference to self to avoid
        # circular reference.
        weak_self = weakref.ref(self)
        sensor_game.sensor.listen(lambda image: CameraManager._parse_image(weak_self, image, config_index,
            self.sensors.index(sensor_game)))

    def render(self, display, index):
        if self.sensors[index].surface is not None:
            display.blit(self.sensors[index].surface,(0, 0))

    @staticmethod
    def _parse_image(weak_self, image, config_index,index):
        self = weak_self() 
        if not self:
            return    
        if self.sensors_config[config_index][0].startswith('sensor.lidar'):
            points = np.frombuffer(image.raw_data, dtype=np.dtype('f4'))
            points = np.reshape(points, (int(points.shape[0] / 3), 3))
            lidar_data = np.array(points[:, :2])
            lidar_data *= min(self.hud.dim) / 100.0
            lidar_data += (0.5 * self.hud.dim[0], 0.5 * self.hud.dim[1])
            lidar_data = np.fabs(lidar_data)  # pylint: disable=E1111
            lidar_data = lidar_data.astype(np.int32)
            lidar_data = np.reshape(lidar_data, (-1, 2))
            lidar_img_size = (self.hud.dim[0], self.hud.dim[1], 3)
            lidar_img = np.zeros(lidar_img_size)
            lidar_img[tuple(lidar_data.T)] = (255, 255, 255)
            surface=pygame.surfarray.make_surface(lidar_img)
        elif self.sensors_config[config_index][0].startswith('sensor.camera.semantic_segmentation'):
            image.convert(self.sensors_config[config_index][1])
            array = np.frombuffer(image.raw_data, dtype=np.dtype("uint8"))
            array = np.reshape(array, (image.height, image.width, 4))
            array = array[:, :, :3]
            array = array[:, :, ::-1]
            self.steering_angle,array=image_processing.lane_centering(array,self.steering_angle) #change method road_centering or lane_centering
            surface=pygame.surfarray.make_surface(array.swapaxes(0, 1)) 
        else:
            image.convert(self.sensors_config[config_index][1])
            array = np.frombuffer(image.raw_data, dtype=np.dtype("uint8"))
            array = np.reshape(array, (image.height, image.width, 4))
            array = array[:, :, :3]
            array = array[:, :, ::-1]
            surface=pygame.surfarray.make_surface(array.swapaxes(0, 1)) 
        self.sensors[index].surface=surface 

# ==============================================================================
# -- HUD -----------------------------------------------------------------------
# ==============================================================================

class HUD(object):
    def __init__(self, width, height):
        self.dim = (width, height)
        font = pygame.font.Font(pygame.font.get_default_font(), 20)
        fonts = [x for x in pygame.font.get_fonts() if 'mono' in x]
        default_font = 'ubuntumono'
        mono = default_font if default_font in fonts else fonts[0]
        mono = pygame.font.match_font(mono)
        self._font_mono = pygame.font.Font(mono, 14)
        self._show_info = True
        self._info_text = []
        self.sensors_mini_surface= []

    def tick(self, vehicle):
        if not self._show_info:
            return
        v = vehicle.get_velocity()
        c = vehicle.get_control()
        self._info_text = [
            'Speed:   % 15.0f km/h' % (3.6 * math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2))]
        if isinstance(c, carla.VehicleControl):
            self._info_text += [
                ('Throttle:', c.throttle, 0.0, 1.0),
                ('Steer:', c.steer, -1.0, 1.0),
                ('Brake:', c.brake, 0.0, 1.0)]

    def toggle_info(self):
        self._show_info = not self._show_info

    def render(self, display):
        if self._show_info:
            info_surface = pygame.Surface((220, self.dim[1]))
            info_surface.set_alpha(100)
            display.blit(info_surface, (0, 0))
            v_offset = 10
            for sensor in self.sensors_mini_surface:
                if sensor.surface is not None:
                 display.blit(pygame.transform.scale(sensor.surface, (200, 90)), (10, v_offset))
                 v_offset += 100
            bar_h_offset = 100
            bar_width = 106
            for item in self._info_text:
                if v_offset + 18 > self.dim[1]:
                    break
                if isinstance(item, list):
                    if len(item) > 1:
                        points = [(x + 8, v_offset + 8 + (1.0 - y) * 30) for x, y in enumerate(item)]
                        pygame.draw.lines(display, (255, 136, 0), False, points, 2)
                    item = None
                    v_offset += 18
                elif isinstance(item, tuple):
                    if isinstance(item[1], bool):
                        rect = pygame.Rect((bar_h_offset, v_offset + 8), (6, 6))
                        pygame.draw.rect(display, (255, 255, 255), rect, 0 if item[1] else 1)
                    else:
                        rect_border = pygame.Rect((bar_h_offset, v_offset + 8), (bar_width, 6))
                        pygame.draw.rect(display, (255, 255, 255), rect_border, 1)
                        f = (item[1] - item[2]) / (item[3] - item[2])
                        if item[2] < 0.0:
                            rect = pygame.Rect((bar_h_offset + f * (bar_width - 6), v_offset + 8), (6, 6))
                        else:
                            rect = pygame.Rect((bar_h_offset, v_offset + 8), (f * bar_width, 6))
                        pygame.draw.rect(display, (255, 255, 255), rect)
                    item = item[0]
                if item:  # At this point has to be a str.
                    surface = self._font_mono.render(item, True, (255, 255, 255))
                    display.blit(surface, (8, v_offset))
                v_offset += 18

if __name__ == '__main__':

    main()
